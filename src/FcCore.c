#include "FcCore.h"

Display *FcDisplay;

FcGL_t s_fcGL = {0};
FcGLX_t s_fcGLX = {0};

const char s_FcShaderVsDefault[] = {
#include "BINARY/FcGL_Button.vs.bin"
        ,0
};
const char s_FcShaderFsDefault[] = {
#include "BINARY/FcGL_Button.fs.bin"
        ,0
};


uint8_t FcInitShaderData;
uint8_t FcInitWindowData;

GLenum glCheckError(const char *file, int line);

#define Fc_glCheckError() glCheckError(__FILE__, __LINE__)

int FcErrors(Display* display, XErrorEvent* event){
    printf("%d\n", event->error_code);
    return 0;
}

void APIENTRY
glCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message,
    const void* userParam) {
    GLuint i_0, i_1, i_2;
    GLchar* glCallbackMessages[] = {
        "Not found\n",
        "Calls to the OpenGL API\n",
        "Calls to a window-system API\n",
        "A compiler for a shading language\n",
        "An application associated with OpenGL \n",
        "Generated by the user of this application\n",
        "Some source that isn't one of these\n",
        "An error, typically from the API\n",
        "Some behavior marked deprecated has been used\n",
        "Something has invoked undefined behavior\n",
        "Some functionality the user relies upon is not portable\n",
        "Code has triggered possible performance issues\n",
        "Command stream annotation\n",
        "Group pushing\n",
        "Pop Group\n",
        "Some type that isn't one of these ",
        "All OpenGL Errors, shader compilation/linking errors, or highly-dangerous undefined behavior\n",
        "Major performance warnings, shader compilation/linking warnings, or the use of deprecated functionality\n",
        "Redundant state change performance warning, or unimportant undefined behavior\n",
        "Anything that isn't an error or performance issue.\n"
    };
    i_0 = i_1 = i_2 = 0;
    if (id == 131169 || id == 131185 || id == 131218 || id == 131204) return;
    printf("\n---------------\nDebug message (%i): %s\n", id, message);
    switch (source)
    {
    case GL_DEBUG_SOURCE_API: i_0 = 1; break;
    case GL_DEBUG_SOURCE_WINDOW_SYSTEM: i_0 = 2; break;
    case GL_DEBUG_SOURCE_SHADER_COMPILER: i_0 = 3; break;
    case GL_DEBUG_SOURCE_THIRD_PARTY: i_0 = 4; break;
    case GL_DEBUG_SOURCE_APPLICATION: i_0 = 5; break;
    case GL_DEBUG_SOURCE_OTHER: i_0 = 6; break;
    }
    switch (type)
    {
    case GL_DEBUG_TYPE_ERROR: i_1 = 7; break;
    case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: i_1 = 8; break;
    case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: i_1 = 9; break;
    case GL_DEBUG_TYPE_PORTABILITY: i_1 = 10; break;
    case GL_DEBUG_TYPE_PERFORMANCE: i_1 = 11; break;
    case GL_DEBUG_TYPE_MARKER: i_1 = 12; break;
    case GL_DEBUG_TYPE_PUSH_GROUP: i_1 = 13; break;
    case GL_DEBUG_TYPE_POP_GROUP: i_1 = 14; break;
    case GL_DEBUG_TYPE_OTHER: i_1 = 15; break;
    }
    switch (severity)
    {
    case GL_DEBUG_SEVERITY_HIGH: i_2 = 16; break;
    case GL_DEBUG_SEVERITY_MEDIUM: i_2 = 17; break;
    case GL_DEBUG_SEVERITY_LOW: i_2 = 18; break;
    case GL_DEBUG_SEVERITY_NOTIFICATION: i_2 = 19; break;
    }
    printf("%s %s %s", glCallbackMessages[i_0], glCallbackMessages[i_1], glCallbackMessages[i_2]);
}



void FcGLWindow_freeThreadContext(FcGLWindow_t *window) {
    FcGLX_freeContext(&s_fcGLX, &window->mContext, FcDisplay);
}

void FcGLWindow_initThreadContext(GLXFBConfig mConfig, FcGLWindow_t *window) {
    FcGLX_initDebugContext(&s_fcGLX, &window->mContext, FcDisplay, &mConfig, window->window);
    FcGL_setDebugCallback(&s_fcGL);
    printf("GL Renderer: %s\n", glGetString(GL_RENDERER));
    printf("GL Version: %s\n", glGetString(GL_VERSION));
    printf("GLSL Version: %s\n", glGetString(GL_SHADING_LANGUAGE_VERSION));
    //xFree(mConfig);
}
#ifdef WIN32
DWORD __stdcall Fc_ThreadConsumer(void* thread) {
#elif (__linux)
void *Fc_ThreadConsumer(void *thread) {
#endif
    Fc_ProducerConsumer_t *m_thread = (Fc_ProducerConsumer_t *) thread;
    Fc_ProducerConsumerData_t value;
    Fc_ProducerConsumerData_t callback = {0};
    size_t i = 0;
    while (1) {
        FcSemaphore_Dec(&m_thread->m_empty);
        FcMutex_Lock(&m_thread->m_mutex);
        m_thread->i--;
        value = m_thread->m_queue[i];
        i = m_thread->i ? i + 1 : 0;
        FcMutex_Unlock(&m_thread->m_mutex);
        FcSemaphore_Inc(&m_thread->m_full);
        switch (value.id) {
            case e_FcGL_exit:
                return 0;
            case e_FcGL_callFunction_fp:
                ((void (*)(void *)) value.s0.v)(value.s1.v);
                break;
            case e_FcGL_callFunction_fpp:
                ((void (*)(void *, void *)) value.s0.v)(value.s1.v, value.s2.v);
                break;
            case e_FcGL_callFunction_fup:
                ((void (*)(unsigned, void *)) value.s0.v)(value.s1.u, value.s2.v);
                break;
            case e_FcGL_callFunction_fff:
                ((void (*)(float, float)) value.s0.v)(value.s1.f, value.s2.f);
                break;
            case e_FcGL_callbackFunction_exit:
                callback = (Fc_ProducerConsumerData_t) {0, 0, 0, 0};
                break;
            case e_FcGL_callbackFunction_fp:
            case e_FcGL_callbackFunction_fpp:
            case e_FcGL_callbackFunction_fup:
            case e_FcGL_callbackFunction_fff:
                callback = value;
                break;
        }
        while (m_thread->i == 0 && callback.id) {
            switch (callback.id) {
                case e_FcGL_callbackFunction_fp:
                    ((void (*)(void *)) callback.s0.v)(callback.s1.v);
                    break;
                case e_FcGL_callbackFunction_fpp:
                    ((void (*)(void *, void *)) callback.s0.v)(callback.s1.v, callback.s2.v);
                    break;
                case e_FcGL_callbackFunction_fup:
                    ((void (*)(unsigned, void *)) callback.s0.v)(callback.s1.u, callback.s2.v);
                    break;
                case e_FcGL_callbackFunction_fff:
                    ((void (*)(float, float)) callback.s0.v)(callback.s1.f, callback.s2.f);
                    break;
            }
        }
    }

    return 0;
}
